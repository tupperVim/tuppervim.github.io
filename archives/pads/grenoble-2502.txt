# Astuces du jour

## Mapping sur claviers ergonomiquesâ€¯: souvent `,/;` (rÃ©pÃ©ter le dernier mouvement avec f/t pour chercher un caractÃ¨re spÃ©cifique) sont sur la mÃªme touche contrairement au qwerty-US et la , est en accÃ¨s direct avec ; en shift. Or on veut plus souvent rÃ©pÃ©ter en avant quâ€™en arriÃ¨re. Il peut-Ãªtre intÃ©ressant de les inverserâ€¯:
nnoremap , ;
nnoremap ; ,

Autres mappings liÃ©sâ€¯:
https://ergol.org/articles/vim_pour_les_ergonautes/
https://fabi1cazenave.github.io/slides/2024-jdll-vim-ergo/

## Quelques astuces de dÃ©placements quâ€™on oublie parfoisâ€¯:
f/F{char}â€¯: pour se dÃ©placer jusquâ€™au prochain/prÃ©cÃ©dent caractÃ¨re `char` sur la ligne (il nâ€™est pas interprÃªtÃ©, f@ va au prochain arobase sur la ligne et ne va pas lancer une macro)
t/T{char}â€¯: comme f mais sert Ã  Â«â€¯atteindreâ€¯Â» ce caractÃ¨re, le curseur sâ€™arrÃªte une case avant.
g_/$â€¯: lors des sÃ©lections, $ va jusquâ€™Ã  la fin de ligne (retour Ã  la ligne inclus, par exemple `^"+y$` va copier dans le presse papier du premier caractÃ¨re imprimable Ã  la fin de ligne + retour chariot), et `g_` ne va que jusquâ€™au dernier caractÃ¨re qui nâ€™est pas un retour Ã  ligne ou un caractÃ¨re dâ€™espacement (ainsi `^"+yg_` ne contiendra pas les trailing spaces ni le retour chariot de fin).

## Ã‰ditions de macros dans vimâ€¯:

enregistrement de macroâ€¯: q[nom], jouer une macroâ€¯: @[nom]

Les macros sont des registres (vous savez, ce qui fait office de presse papier), et partagent les mÃªmes noms

On peut les Ã©diter comme des registres (par exemple un registre dans `q` peut Ãªtre collÃ© sur une nouvelle ligne via "qp et enregistrÃ© ensuite via 0"qyg_ aprÃ¨s ).
Plus dâ€™info sur les registresâ€¯: https://pcoves.gitlab.io/blog/vim-registers/

On peut continuer une macro avec la lettre majuscule associÃ©e, par exemple si on fait une macro dans `q` qui rajoute une virgule Ã  la fin de la ligne mais quâ€™on a oubliÃ© de joindre les lignes, on peut le faire avec `qQ`
Q pour rÃ©pÃ©ter la derniÃ¨re macro enregistrÃ©e
Par exemple `qq` pour enregistrer une petite macro peut-Ãªtre rejouÃ©e rapidement ensuite via Q
@@ pour rÃ©pÃ©ter la derniÃ¨re macro jouÃ©e

Comme beaucoup de commandes dans vim, les commandes de macros peuvent Ãªtre rÃ©pÃ©tÃ©es en spÃ©cifiant un nombre avantâ€¯: `42@q` par exemple pour jouer une macro 42 fois.
macros rÃ©cursivesâ€¯: on peut appeler des macros dans des macros, voire rappeler la mÃªme macro elle-mÃªme. Elle se jouera jusquâ€™Ã  atteindre la fin du fichier ou lÃ¨vera une erreur (par exemple si on fait une recherche pour atteindre le motif suivant, sâ€™il nâ€™y a plus de motif, lâ€™exÃ©cution sâ€™arrÃªtera).

C-c pour arrÃªter lâ€™exÃ©cution dâ€™une macro (par exemple si la rÃ©cursion nâ€™atteint jamais une de ses conditions dâ€™arrÃªt)
`q:` pour voir les derniÃ¨res commandes tapÃ©es dans `:`, les Ã©diter (dans un buffer vim) et les relancer au besoin. Utile pour rÃ©parer une erreur de `s//` par exemple

La mÃªme chose existe pour les recherches avec `q/` par exemple

## Le mapping dans vim

ProblÃ¨meâ€¯: on peut uniquement mettre des fonctions sans argument dans les mappings

Solutionâ€¯: fonctions dâ€™ordre supÃ©rieur pour abstraire les commandes similaires mais prenant des paramÃ¨tres diffÃ©rents. Ansi on curryfie les appels de fonctions lua pour avoir une syntaxe plus propre.

Bonusâ€¯: Comme en lua il est possible de ne pas mettre de parenthÃ¨se dans les appels de fonction si lâ€™argument suivant est un tableau ou une chaÃ®ne, on peut avoir dans sa config lua du sucre syntaxique pour avoir des remapping du type `nmap '<leader>q' ':qa<cr>'` plus lisibles pour les mappings simples.

Nuke va faire un plugin pour Ã§a ğŸ¤
En attendant, la configuration est disponible par lÃ â€¯:
https://github.com/Nuclear-Squid/dotFiles/blob/469c87a40d737a0f9a1ac83c0a41493e0af42db8/nvim/lua/utils.lua
https://github.com/Nuclear-Squid/dotFiles/blob/469c87a40d737a0f9a1ac83c0a41493e0af42db8/nvim/lua/mapping_functions.lua

Avec pour exemples du sucre syntaxiqueâ€¯:
https://github.com/Nuclear-Squid/dotFiles/blob/469c87a40d737a0f9a1ac83c0a41493e0af42db8/nvim/init.lua#L116-L144

## undotree

https://github.com/mbbill/undotree

Pouvoir visualiser les arbres dâ€™undo + navigation avec 'g+/g-'
Aide Ã  avoir une reprÃ©sentation de lâ€™arbre dâ€™historique pour les futures opÃ©rations (similaire au fait de tester les textobjects en mode visuel avant de les utiliser â€œnormalementâ€)

## Back to the basicsâ€¯: makeprg

La commande appelÃ©e avec `:make` dans vim est dÃ©finie par lâ€™option `makeprg` (`:set makeprg=â€¦`)
Peut-Ãªtre spÃ©cifiÃ©e facilement par `filetype' dans `after/ftplugin`, ou via des autocommands
Les erreurs sont listÃ©es dans le quickfix, leur format peut-Ãªtre spÃ©cifiÃ© par lâ€™option `errorformat`
Câ€™est un exemple de la modularitÃ© de vim et son cÃ´tÃ© language-agnostic.
Similairement, la commande appelÃ©e par `gq` pour reformater son code peut-Ãªtre spÃ©cifiÃ©e via `formatprg`

## LTeX-ls

https://github.com/valentjn/ltex-ls

Language server pour languagetool, pour permettre la vÃ©rification grammaticale dans plusieurs langues
Disponible dans mason

Avantagesâ€¯:

AccÃ¨s aux mÃªmes commandes de base quâ€™avec dâ€™autres serveur le langageâ€¯:
Code action pour rÃ©parer automatiquement quand câ€™est possible
Diagnostic list dans loclist ou dans telescope
Recherche des erreurs lors de la sortie du mode dâ€™insertion
Vient en complÃ©mentaritÃ© de `:set spell`
Astuceâ€¯: Pour avoir plusieurs vÃ©rifications orthographiques, sÃ©parer les langues par des virgules. Par exempleâ€¯:
`:set spelllang=fr,en`
Attentionâ€¯: Ã§a ne capturera pas les fautes dâ€™orthographe inter-langue du type â€œconnectionâ€ en franÃ§ais et â€œconnexionâ€ en anglais. Mais en conjonction avec LTeX, Ã§a devrait bien fonctionner (lui devrait avertir si ce genre de cas apparaissait)

Exemple de configurationâ€¯:
https://git.epheme.re/fmouhart/nvim-config-kickstart/src/commit/49407e023c50fa77aa22dff5cdeaea6f9d482785/lua/lsp.lua#L103-L135
